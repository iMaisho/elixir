# ğŸ§‘â€ğŸ« **Cours : Ajout dâ€™un filtre dynamique dans une LiveView Phoenix**


## ğŸ§± Objectif

Ajouter un **champ de recherche interactif** (filtre) qui :

* RÃ©agit en temps rÃ©el Ã  la saisie utilisateur,
* Met Ã  jour dynamiquement la liste affichÃ©e,
* Ne nÃ©cessite **ni changement de page**, **ni rechargement complet**,
* Ne dÃ©pend **pas dâ€™un changeset ou dâ€™un formulaire complexe**.


## ğŸ§© Ã‰tapes complÃ¨tes


### 1. **PrÃ©parer la LiveView â€“ `mount/3`**

#### âœ… Objectif

Initialiser la donnÃ©e du filtre (`""`) et prÃ©parer un `form` compatible avec `<.simple_form>` et `<.input>`.

#### âœ… Actions

* Appeler `to_form/2` avec une map contenant `"filter" => ""`
* Lâ€™assigner dans `:form`
* Charger les donnÃ©es avec `Chats.list_intranet_conversation_with_preload()`

#### ğŸ’¡ Code logique

```elixir
assign(:form, to_form(%{"filter" => ""}, as: :filter_form))
```

> Pourquoi `%{"filter" => ""}` ?
> Parce que Phoenix sait construire un `Phoenix.HTML.Form` Ã  partir dâ€™une map string-keyed.


### 2. **CrÃ©er le formulaire dans le template `.heex`**

#### âœ… Objectif

Afficher un champ de saisie qui dÃ©clenche un Ã©vÃ©nement Ã  chaque frappe.

#### âœ… Actions

* Utiliser `<.simple_form>` avec `phx-change`
* Utiliser `<.input>` avec `field={@form[:filter]}`

#### ğŸ’¡ Points clÃ©s

* Le `phx-change="filter"` dÃ©clenche un `handle_event("filter", ...)`
* Le `id="..."` permet de cibler le formulaire si besoin


### 3. **GÃ©rer lâ€™Ã©vÃ©nement `filter` dans la LiveView**

#### âœ… Objectif

Mettre Ã  jour dynamiquement la liste des conversations en fonction de la recherche.

#### âœ… Actions

* Lire la valeur du champ depuis les params
* RÃ©appeler `Chats.list_intranet_conversation_with_preload/0`
* Filtrer cÃ´tÃ© serveur avec `Enum.filter`
* Mettre Ã  jour :

  * `:form` pour conserver la valeur tapÃ©e
  * le `:stream` pour rÃ©afficher la liste filtrÃ©e

#### ğŸ’¡ Pourquoi rÃ©assigner `:form` ?

Pour que la valeur saisie reste visible aprÃ¨s le `handle_event`.

#### ğŸ’¡ Pourquoi `reset: true` dans `stream` ?

Pour que Phoenix **remplace toute la liste** (et non juste fusionner les ajouts/suppressions).


### 4. **PrÃ©charger correctement les associations**

#### âœ… Objectif

Ã‰viter les erreurs `Ecto.Association.NotLoaded`.

#### âœ… Actions

Sâ€™assurer que la fonction appelÃ©e pour charger les conversations inclut `preload(:intranet_messages)`.

#### ğŸ’¡ Point dâ€™attention

Si tu filtres avec une fonction qui nâ€™inclut pas le `preload`, Phoenix va crasher dÃ¨s que tu essayes de faire un `for` sur lâ€™association.


### 5. **VÃ©rifications cÃ´tÃ© client (JS)**

#### âœ… Objectif

Sâ€™assurer que Phoenix LiveView fonctionne bien **en temps rÃ©el (WebSocket)**.

#### âœ… Actions

* VÃ©rifier que le fichier `assets/js/app.js` contient bien le `LiveSocket` initialisÃ©.
* VÃ©rifier que le script JS est bien inclus dans le `root.html.heex`.

#### ğŸ’¡ SymptÃ´me courant

Si le champ recharge la page â†’ câ€™est que **le JS LiveView ne fonctionne pas** (ou mal initialisÃ©).


## ğŸ§ª RÃ©sultat attendu

* âœ… Un champ qui filtre les conversations au fur et Ã  mesure.
* âœ… Aucune relecture de page.
* âœ… Liste mise Ã  jour dynamiquement.
* âœ… Code lÃ©ger, clair, sans changeset inutile.


## ğŸ§¼ Bonnes pratiques

* Ne pas mÃ©langer `@filter` et `@form[:filter]` dans les templates.
* Toujours utiliser `to_form(...)` avec une map string-keyed ou un changeset.
* Ajouter un `phx-submit` ou un bouton si tu veux filtrer manuellement en plus du live.
