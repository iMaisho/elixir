# Best Practices

## Rappels

### Nomenclature

- Utiliser des **noms clairs, explicites et coh√©rents** pour les modules, les sch√©mas et les variables.
- Les **modules** (ex : contexts, schemas) utilisent la **camel case** (`IntranetMessage`, `UserAccount`).
- Les **tables en base de donn√©es** et **routes** utilisent la **snake case** plurielle (`intranet_messages`, `user_accounts`).
- Les **fonctions** sont en **snake case** et doivent **d√©crire pr√©cis√©ment leur action** (`list_intranet_messages`, `create_user`, `get_conversation_with_preload!`).
- Les **associations** (`has_many`, `belongs_to`) doivent **reprendre les noms exacts des modules li√©s**.

**Exemple concret** :
```elixir
schema "intranet_messages" do
  belongs_to :intranet_conversation, IntranetConversation
end
```

### Conventions de nomenclature avanc√©es

#### Underscores `_`

On utilise un underscore seul `_` ou un nom de varable commen√ßant par un underscore `_variable_name` pour une variable qui ne sera pas utilis√©e.

On peut √©galement utiliser l'underscore pour nommer une fonction, ce qui fera qu'elle ne sera pas import√©e par d√©faut lors de l'import de son module.

```elixir
defmodule Example do
  def _wont_be_imported do
    :oops
  end
end

import Example
_wont_be_imported()
** (CompileError) iex:1: undefined function _wont_be_imported/0
```

Les fonctions ou macros dont le nom est entour√© de double underscore (comme `__info__/1`, `__MODULE__/0`, etc.) ne sont pas juste une convention stylistique : **elles sont r√©serv√©es pour le compilateur et le syst√®me d‚Äôex√©cution.**

Elles servent principalement √† ajouter ou interroger des m√©tadonn√©es sur un module √† la compilation ou √† l‚Äôex√©cution.

##### `__info__/1` : Obtenir les infos d‚Äôun module
Chaque module Elixir g√©n√®re automatiquement une fonction `__info__/1`.

Tu peux l‚Äôutiliser pour demander diff√©rentes m√©tadonn√©es sur ce module. Par exemple :
``` elixir
String.__info__(:functions)

# Renvoie :
[
  at: 2,
  capitalize: 1,
  chunk: 2,
  ...
]
```
üëâ Ici, tu obtiens la liste des fonctions export√©es par le module String, avec leur arit√© (nombre d‚Äôarguments).

##### Les 5 formes sp√©ciales

Ces macros/fonctions sont utilis√©es √† la compilation, notamment dans les macros, pour obtenir le contexte dans lequel le code est en train de se compiler.


- `__CALLER__/0`	Donne des infos sur l‚Äôappelant actuel d‚Äôune macro : nom du module, ligne, fichier, etc.
- `__ENV__/0`	Donne l‚Äôenvironnement de compilation courant (module, fonctions import√©es, etc.)
- `__MODULE__/0`	Renvoie le nom du module courant
- `__DIR__/0`	Renvoie le chemin du fichier courant
- `__STACKTRACE__/0`	Renvoie la stacktrace de l‚Äôexception en cours (√† utiliser dans rescue)


#### Point d'exclamation `!`

En g√©n√©ral lorsqu'on d√©finit une fonction, on veut g√©rer les cas d'erreur pour pouvoir r√©agir en cons√©quence sur l'application (envoyer un message d'erreur ou autre..)

```elixir
case File.read(file) do
  {:ok, body} -> # do something with the `body`
  {:error, reason} -> # handle the error caused by `reason`
end
```

Cependant, quand on sait que l'erreur est improbable ou critique, on utilise `!`

```elixir
File.read!("file.txt")
"file contents"
File.read!("no_such_file.txt")
** (File.Error) could not read file no_such_file.txt: no such file or directory
```

Cela permet de lever une erreur plus explicite, l√† o√π l'exemple d'avant l√®verait seulement une erreur de Pattern Matching `MatchError`


#### Point d'interrogation `?`

On utilise le point d'interrogation √† la fin du nom d'une fonction qui retourne un `bool`

#### Pr√©fixe `is_`

On l'utilise pour nommer notre fonction si elle est autoris√©e dans une **garde** (`guard clause`), une condition suppl√©mentaire que tu peux ajouter √† une clause de fonction ou de pattern matching pour affiner le comportement de la fonction.

```elixir
defmodule Test do
  def double(x) when is_integer(x), do: x * 2
  def double(x), do: x
end

Test.double(10) # => 20
Test.double("a") # => "a"
```

Dans une guard clause, on ne peux pas utiliser n‚Äôimporte quelle fonction !
Seules certaines fonctions dites "pures" et s√ªres (souvent en termes de performances ou d'effets de bord) sont autoris√©es.

Ces fonctions :
- sont d√©terministes
- ne l√®vent pas d‚Äôexception
- ne modifient rien
- sont tr√®s rapides (souvent directement int√©gr√©es dans la VM)

C‚Äôest pour cela que les fonctions valides en garde utilisent le pr√©fixe `is_ `   pour suivre la convention Erlang et signaler qu‚Äôelles peuvent √™tre utilis√©es dans une garde.


#### Noms sp√©ciaux en Elixir

Certains noms ont une signification particuli√®re en Elixir. Voici les cas les plus courants.



##### `length` et `size`

Lorsque vous voyez **`size`** dans le nom d'une fonction, cela signifie que l‚Äôop√©ration s‚Äôex√©cute en **temps constant** (`O(1)`) car la taille est **stock√©e avec la structure de donn√©es**.

**Exemples** : `map_size/1`, `tuple_size/1`

Lorsque vous voyez **`length`**, l‚Äôop√©ration s‚Äôex√©cute en **temps lin√©aire** (`O(n)`) car la structure de donn√©es doit √™tre **parcourue enti√®rement**.

**Exemples** : `length/1`, `String.length/1`

üëâ En r√©sum√©, les fonctions contenant `size` prennent **le m√™me temps** peu importe la taille des donn√©es, tandis que celles avec `length` deviennent **plus lentes** √† mesure que la structure grandit.


##### `get`, `fetch`, `fetch!`

Dans les structures de type cl√©-valeur, les fonctions `get`, `fetch` et `fetch!` ont des comportements bien d√©finis :

- `get` renvoie la **valeur demand√©e** si elle existe, ou une **valeur par d√©faut** (par d√©faut : `nil`) si la cl√© est absente.
- `fetch` renvoie `{:ok, valeur}` si la cl√© existe, ou `:error` sinon.
- `fetch!` l√®ve une **erreur** si la cl√© est absente, sinon elle renvoie la valeur.

**Exemples** :
`Map.get/2`, `Map.fetch/2`, `Map.fetch!/2`
`Keyword.get/2`, `Keyword.fetch/2`, `Keyword.fetch!/2`


##### `compare`

Une fonction `compare/2` doit retourner :

- `:lt` si le premier √©l√©ment est inf√©rieur au second,
- `:eq` s‚Äôils sont √©quivalents,
- `:gt` si le premier est sup√©rieur.

**Exemple** : `DateTime.compare/2`

Cette convention est importante car elle est utilis√©e notamment par des fonctions comme `Enum.sort/2`.


### mix format, mix credo, mix test

- **mix format**
  ‚ûî **Obligatoire** avant chaque commit.
  ‚ûî Reformate automatiquement le code pour garantir **une mise en forme standardis√©e** (indentation, espaces, retours √† la ligne).

- **mix credo**
  ‚ûî **√Ä ex√©cuter r√©guli√®rement pendant le d√©veloppement**.
  ‚ûî D√©tecte les probl√®mes de style, de structure et les risques techniques (ex : fonctions trop longues, duplication de code).
  ‚ûî Corriger les alertes importantes avant de merger ou livrer.

- **mix test**
  ‚ûî Doc : https://hexdocs.pm/mix/Mix.Tasks.Test.html
  ‚ûî **√Ä ex√©cuter syst√©matiquement avant chaque commit**.
  ‚ûî V√©rifie que **l‚Äôensemble du projet reste fonctionnel** apr√®s chaque modification.
  ‚ûî Aucun commit ne doit √™tre fait si des tests √©chouent.

**Encha√Ænement standard conseill√©** avant toute validation :
```bash
mix format
mix credo --strict
mix test
```

## Workflow Frixel

Lorsque vous souhaitez r√©aliser une nouvelle fonctionnalit√© (ou une nouvelle t√¢che) sur un projet, vous devez respecter les √©tapes suivantes :

### **I - Cr√©er le ticket JIRA associ√©**

[**JIRA**](https://cristal-flow.atlassian.net/jira) est un outil de gestion de projet et de suivi de bugs. Beaucoup utilis√© en agile, JIRA permet de faciliter la planification de t√¢ches. Nous l‚Äôutilisons afin de permettre un suivi constant et maitris√© des diff√©rentes t√¢ches (tech ou non tech) √† r√©aliser sur un projet sp√©cifique.

Le tableau de bord d‚Äôun projet JIRA contient des tickets pr√©sents dans des colonnes diff√©rentes, qui sp√©cifient le niveau d‚Äôavancement des t√¢ches. Un ticket JIRA doit correspondre soit √† une t√¢che (nouvelle fonctionnalit√©, t√¢che terchnique, une refactorisatonn de code, ect) ou √† un bug/incident √† corriger.

### **II - Cr√©√© la branche GIT pour commencer le d√©veloppement de la feature**

On cr√©√© une nouvelle branche toujours √† partir de la branche principale (en g√©n√©ral nomm√©e `master` ou `main`) afin de s‚Äôassurer d‚Äôembarquement les derniers changements r√©cemment publi√©s sur la derni√®re version du projet. Voici la commande pour cr√©er une nouvelle branche :

`git checkout -b nom-de-la-feature-√†-impl√©menter`

Une fois la branche cr√©√©e, vous pouvez commencer votre impl√©mentation.

‚ö†Ô∏è **Important √† savoir** : Voici les 10 commandements de la bonne gestion d‚Äôune branche lors de l‚Äôimpl√©mentation d‚Äôune nouvelle fonctionnalit√© ou tout autre t√¢che technique :

- Le nom de ta branche doit id√©alement porter le m√™me nom que le ticket JIRA associ√©
- Le nom de ma branche doit contenir le num√©ro de r√©f√©rence du ticket JIRA associ√© √† la t√¢che concern√©e
- Le nom de mes commits doit contenir un mot cl√© qui d√©finit la nature des changements apport√©s par la t√¢che que je souhaite effectu√© (respect de la [**nomenclature des commits**](https://www.notion.so/JF-TP-2-bonnes-pratiques-git-et-mise-en-place-d-une-CI-1764d1e5f33e80a7b3b6ec01c742bc61?pvs=21) mise en place par mon √©quipe)
- Jamais et au grand jamais je vais m‚Äôamuser √† cr√©er ma branche depuis une branche qui n‚Äôest pas consid√©r√© comme branche principale
- Je dois r√©guli√®rement pousser du code sur ma branche afin de faire des sauvegardes r√©guli√®res de mon niveau d‚Äôavancement

- Ma branche doit toujours √™tre √† jour avec tous les changements qui arrivent sur la branche principale (en utilisant la commande [`git rebase`](https://www.notion.so/JF-TP-2-bonnes-pratiques-git-et-mise-en-place-d-une-CI-1764d1e5f33e80a7b3b6ec01c742bc61?pvs=21))
- Ma branche ne doit jamais avoir une dur√©e de vie sup√©rieur √† 48h
- Ma branche doit √™tre li√©e √† une seule t√¢che
- Ma branche doit √™tre li√©e √† un seul ticket JIRA
- √Ä bas les branches ‚Äú‚Äô*j‚Äôy mets tout ce qui me passe par la t√™te*‚Äù

### **III - Impl√©mentation de la feature**

Ici vous pouvez vous lancez dans la r√©alisation de votre t√¢che et faire des sauvegardes de fa√ßon r√©guli√®re sur votre branche. Voici les trois commandes qui seront vos amis fid√®les durant cette phase :

`git add fichier_1 fichier_2 ...`

`git commit -m "Message du commit"`

`git push`

### **IV - Cr√©ation de la PR**

Une fois la fonctionnalit√© (ou t√¢che) termin√©e, il est temps de cr√©er une ‚Äú***pull request***‚Äù (**PR**) de son travail depuis la branche en cours vers la branche principale.

***On fait une PR afin de proposer aux membres de son √©quipe de faire une revue de code des changements (issues de la t√¢che sur laquelle on a travaill√©) que l‚Äôon souhaite apporter sur le projet.***

**N.B**: *Tout se passe sur l‚Äôinterface graphique de Github (Outils de versioning que nous utilisons)*

<aside>
üí°

‚ö†Ô∏è **Avant de de cr√©er sa PR, il faut toujours s‚Äôassurer que les commandes suivantes ne g√©n√®rent aucune erreur en local (Nous verrons plus tard √† quoi elles servent)** ‚ö†Ô∏è

`mix test`

`mix credo`

</aside>

**Quel format doit avoir le titre de ma PR ?**

Le titre de ma **PR** doit respecter le format suivant :

<aside>
üí°

**`DF-322** **feat**(**mise en place d'un chat collaboratif**) - Cr√©ation de rooms de chat`

**DF-322 : Num√©ro du ticket JIRA**

**feat : Type de t√¢che r√©alis√©e (Cf. Format ‚Äú**[conventional commits](https://www.notion.so/JF-TP-2-bonnes-pratiques-git-et-mise-en-place-d-une-CI-1764d1e5f33e80a7b3b6ec01c742bc61?pvs=21)**‚Äù d√©finis avec l‚Äô√©quipe)**

**mise en place‚Ä¶ : Nom de la t√¢che effectu√©e**

**cr√©ation de ‚Ä¶ : D√©tails de la t√¢che**

</aside>

**Ne pas oublier d‚Äôattribuer un reviewer √† la PR que vous allez cr√©er.**

### **V - Revue de code de la PR et Prise en compte des retours de la revue**

Une fois une PR ouverte :

- En tant que reviewer, vous pouvez faire des retours sur le code propos√©
- En tant que cr√©ateur de la PR vous devez attendre de recevoir des retours propos√©s par la personne en charge de la revue de code.

***Les revues de code vont nous permettre de d√©tecter en amont de la validation du code, des vuln√©rabilit√©s ou erreurs de conception dans le but d‚Äôam√©liorer la qualit√© et maintenabilit√©s du code source de notre projet.***

**N.B**: *Tout se passe sur l‚Äôinterface graphique de Github (Outils de versioning que nous utilisons)*

### **VII - Validation de la PR**

Une fois que les retours (si ils y en a) seront pris en compte, en tant que reviewer , vous pouvez valider la PR.

***La valide de la PR indique que le code examin√© est propre et pr√™t √† √™tre merger sur la branche principale.***

**N.B**: *Tout se passe sur l‚Äôinterface graphique Github (Outils de versioning que nous utilisons)*

### **VIII - Merger le code de la PR sur la branche principale**

Une fois la PR valid√©e, vous (en tant que reviewer) √™tes enfin pr√™t √† merger le code source propos√© vers la branche principale. Ce qu‚Äôil faut savoir avant de merger une PR :

<aside>
üí°

1. ***Toujours penser √† faire ‚Äúun squash and merge‚Äù*** : Il faut √©viter de polluer la branche principale avec tous les commits inutiles que vous avez pouss√© durant votre phase d‚Äôimpl√©mentation. En faisant un ‚Äú***squash and merge***‚Äù, on s‚Äôassure d‚Äôagr√©ger tous les commits de notre travail en un seul commit dont le nom doit √™tre identique √† celui du titre de la PR
2.  ***Vous devez merger sur la branche principale si et seulement si vous avez une pipeline verte***. **Pourquoi** ? Ceci permet d‚Äô√©viter d‚Äôint√©grer des r√©gressions dans le code source de la branche principale.

‚ö∞Ô∏è **Ceux qui vont s‚Äôamuser √† valider et merger des PR qui ont des pipelines rouges seront traqu√©s, retrouv√©s et ‚Ä¶.** üôÇ

</aside>
